URL
[TagOpen "!DOCTYPE" [("html","")],TagText "\n",TagOpen "html" [("itemscope",""),("itemtype","http://schema.org/Blog")],TagText "\n\t",TagOpen "head" [],TagText "\n    ",TagOpen "title" [],TagText "Working With HTML In Haskell - adit.io",TagClose "title",TagText "\n    ",TagOpen "meta" [("http-equiv","Content-Type"),("content","text/html; charset=UTF-8")],TagText "\n    ",TagOpen "meta" [("name","viewport"),("content","width=320")],TagClose "meta",TagText "\n    ",TagOpen "meta" [("itemprop","name"),("content","adit.io")],TagText "\n    ",TagOpen "meta" [("itemprop","description"),("content","Aditya Bhargava's personal blog.")],TagText "\n    ",TagOpen "meta" [("name","description"),("content","Aditya Bhargava's personal blog.")],TagText "\n    ",TagOpen "link" [("href","http://fonts.googleapis.com/css?family=Ovo|Lato:300,900"),("rel","stylesheet")],TagClose "link",TagText "\n    ",TagOpen "link" [("rel","stylesheet"),("href","../css/reset.css")],TagText "\n    ",TagOpen "link" [("rel","stylesheet"),("href","../css/disqus.css")],TagText "\n    ",TagOpen "link" [("rel","stylesheet"),("href","../css/prettify.css")],TagText "\n    ",TagOpen "link" [("rel","stylesheet"),("href","../css/style.css")],TagText "\n    ",TagOpen "link" [("rel","stylesheet"),("href","../css/bootstrap.css")],TagText "\n\t",TagClose "head",TagText "\n  ",TagOpen "body" [("onload","prettyPrint()")],TagText "\n    ",TagOpen "ul" [("id","menu")],TagText "\n      ",TagOpen "li" [],TagOpen "a" [("href","../index.html")],TagText "> adit.io",TagClose "a",TagClose "li",TagText "\n      ",TagOpen "li" [],TagOpen "a" [("href","http://git.io/egon")],TagText "Github",TagClose "a",TagClose "li",TagText "\n      ",TagOpen "li" [("class","highlight")],TagOpen "a" [("href","http://manning.com/bhargava")],TagText "Buy my book! Grokking Algorithms",TagClose "a",TagClose "li",TagText "\n    ",TagClose "ul",TagText "\n    ",TagOpen "div" [("id","container"),("class","container")],TagText "\n      ",TagOpen "div" [("class","row")],TagText "\n        ",TagOpen "div" [("id","content"),("class","span12")],TagText "\n          \n",TagOpen "ul" [("id","sections")],TagText "\n",TagOpen "h2" [],TagText "Contents",TagClose "h2",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#what-is-hxt")],TagText "What Is HXT?",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#why-hxt")],TagText "Why HXT?",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#hello-world")],TagText "Hello World",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#understanding-arrows")],TagText "Understanding Arrows",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#getting-started")],TagText "Getting Started",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#parse-a-string-as-html")],TagText "Parse A String As HTML",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#arrow-interlude-1-hxt-arrows")],TagText "Arrow Interlude #1: HXT Arrows",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#extracting-content")],TagText "Extracting Content",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#pretty-printing")],TagText "Pretty-printing",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#selecting-elements")],TagText "Selecting Elements",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#arrow-interlude-2")],TagText "Arrow Interlude #2",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#children-and-descendents")],TagText "Children And Descendents",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#working-with-text")],TagText "Working With Text",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#modifying-a-node")],TagText "Modifying A Node",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#modifying-children")],TagText "Modifying Children",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#conditionals-ifa")],TagText "Conditionals (ifA)",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#more-conditionals-when-guards-and-filtera")],TagText "More Conditionals (when, Guards, And FilterA)",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#using-functions-as-predicates")],TagText "Using Functions As Predicates",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#using-haskell-functions")],TagText "Using Haskell Functions",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#working-with-lists")],TagText "Working With Lists",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#introducing-handsomesoup")],TagText "Introducing HandsomeSoup",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#avoiding-io")],TagText "Avoiding IO",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#debugging")],TagText "Debugging",TagClose "a",TagClose "li",TagText "\n",TagOpen "li" [],TagOpen "a" [("href","#epilogue")],TagText "Epilogue",TagClose "a",TagClose "li",TagText "\n\n",TagClose "ul",TagText "\n\n          ",TagOpen "h1" [],TagText "Working With HTML In Haskell",TagClose "h1",TagText "\n",TagOpen "time" [],TagText "Written April 14, 2012",TagClose "time",TagText " ",TagOpen "time" [("class","second")],TagText "Updated April 27, 2012",TagClose "time",TagText "\n\n",TagOpen "p" [],TagText "This is a complete guide to using ",TagOpen "a" [("href","http://www.fh-wedel.de/~si/HXmlToolbox/")],TagText "HXT",TagClose "a",TagText " for parsing and processing HTML in Haskell.",TagClose "p",TagText "\n",TagOpen "h2" [("id","what-is-hxt")],TagText "What is HXT?",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "HXT is a collection of tools for processing XML with Haskell. It\8217s a ",TagOpen "a" [("href","http://hackage.haskell.org/package/hxt")],TagText "complex beast",TagClose "a",TagText ", but HXT is powerful and flexible, and very elegant once you know how to use it.",TagClose "p",TagText "\n",TagOpen "h2" [("id","why-hxt")],TagText "Why HXT?",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "Here\8217s how HXT stacks up against some other XML parsers:",TagClose "p",TagText "\n",TagOpen "h3" [("id","hxt-vs-tagsoup")],TagText "HXT vs TagSoup",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://hackage.haskell.org/package/tagsoup-0.12.6")],TagText "TagSoup",TagClose "a",TagText " is the crowd favorite for HTML scraping in Haskell, but it\8217s a bit too basic for my needs.",TagClose "p",TagText "\n",TagOpen "h3" [("id","hxt-vs-haxml")],TagText "HXT vs HaXml",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "HXT is based on ",TagOpen "a" [("href","http://projects.haskell.org/HaXml/")],TagText "HaXml",TagClose "a",TagText ". The two are very similar, but I think HXT is a little more elegant.",TagClose "p",TagText "\n",TagOpen "h3" [("id","hxt-vs-hexpat")],TagText "HXT vs hexpat",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://hackage.haskell.org/package/hexpat")],TagText "hexpat",TagClose "a",TagText " is a high-performance xml parser. It might be more appropriate depending on your use case. hexpat lacks a collection of tools for processing the HTML, but you can try ",TagOpen "a" [("href","http://legacy.cs.uu.nl/daan/parsec.html")],TagText "Parsec",TagClose "a",TagText " for that bit.",TagClose "p",TagText "\n",TagOpen "h3" [("id","hxt-vs-xml-text.xml.light")],TagText "HXT vs xml (Text.XML.Light)",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "I haven\8217t used ",TagOpen "a" [("href","http://hackage.haskell.org/package/xml")],TagText "Text.XML.Light",TagClose "a",TagText ". If you have used it and liked it, please let me know!",TagClose "p",TagText "\n",TagOpen "p" [],TagText "The one thing all these packages have in common is poor documentation.",TagClose "p",TagText "\n",TagOpen "div" [("class","figure")],TagText "\n  ",TagOpen "img" [("src","../imgs/einstein.jpg"),("alt","Einstein after spending several hours trying to find documentation on XML parsers")],TagClose "img",TagText "\n  ",TagOpen "p" [("class","caption")],TagText "Einstein after spending several hours trying to find documentation on XML parsers",TagClose "p",TagText "\n",TagClose "div",TagText "\n",TagOpen "h2" [("id","hello-world")],TagText "Hello World",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "To whet your appetite, here\8217s a simple script that uses HXT to get all links on a page:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "import Text.XML.HXT.Core\n\nmain = do\n  html <- readFile \"test.html\"\n  let doc = readString [withParseHTML yes, withWarnings no] html\n  links <- runX $ doc //> hasName \"a\" >>> getAttrValue \"href\"\n  mapM_ putStrLn links",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h2" [("id","understanding-arrows")],TagText "Understanding Arrows",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "I don\8217t assume any prior knowledge of Arrows. In fact, one of the goals of this guide is to help you understand Arrows a little better.",TagClose "p",TagText "\n",TagOpen "h3" [("id","the-least-you-need-to-know-about-arrows")],TagText "The Least You Need to Know About Arrows",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "Arrows are a way of representing computations that take an input and return an output. All Arrows take a value of type ",TagOpen "code" [("class","lang-rb")],TagText "a",TagClose "code",TagText " and return a value of type ",TagOpen "code" [("class","lang-rb")],TagText "b",TagClose "code",TagText ". All Arrow types look like ",TagOpen "code" [("class","lang-rb")],TagText "Arrow a b",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "-- an Arrow that takes an `a` and returns a `b`:\narrow1 :: SomeType a b\n\n-- an Arrow that takes a `b` and returns a `c`:\narrow2 :: SomeType b c\n\n-- an Arrow that takes a `String` and returns an `Int`:\narrow3 :: SomeType String Int",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Arrows sound like functions! In fact, functions are arrows.",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "-- a function that takes an Int and returns a Bool\nodd :: Int -> Bool\n\n-- also, an Arrow that takes an Int and returns a Bool\nodd :: (->) Int Bool",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Don\8217t get confused by the two different type signatures! ",TagOpen "code" [("class","lang-rb")],TagText "Int -> Bool",TagClose "code",TagText " is just the infix way of writing ",TagOpen "code" [("class","lang-rb")],TagText "(->) Int Bool",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "h3" [("id","arrow-composition-with-and")],TagText "Arrow Composition With ",TagOpen "code" [("class","lang-rb")],TagText "<<<",TagClose "code",TagText " and ",TagOpen "code" [("class","lang-rb")],TagText ">>>",TagClose "code",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "You\8217ll be using ",TagOpen "code" [("class","lang-rb")],TagText ">>>",TagClose "code",TagText " a lot with HXT, so it\8217s a good idea to understand how it works.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText ">>>",TagClose "code",TagText " composes two arrows into a new arrow.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "We could compose ",TagOpen "code" [("class","lang-rb")],TagText "length",TagClose "code",TagText " and ",TagOpen "code" [("class","lang-rb")],TagText "odd",TagClose "code",TagText " like so: ",TagOpen "code" [("class","lang-rb")],TagText "odd . length",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "Since functions are Arrows, we could also compose them like so: ",TagOpen "code" [("class","lang-rb")],TagText "length >>> odd",TagClose "code",TagText " or ",TagOpen "code" [("class","lang-rb")],TagText "odd <<< length",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "They\8217re all exactly the same!",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> odd . length $ [1, 2, 3]\nTrue\nghci> length >>> odd $ [1, 2, 3]\nTrue\nghci> odd <<< length $ [1, 2, 3]\nTrue",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "A function is the most basic type of arrow, but there are many other types. HXT defines its own Arrows, and we will be working with them a lot.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "Let\8217s get started. Don\8217t worry if Arrows still seem unclear. We will be writing a lot of examples, so they should become clear soon enough.",TagClose "p",TagText "\n",TagOpen "h2" [("id","getting-started")],TagText "Getting Started",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "strong" [],TagText "Step 1",TagClose "strong",TagText ": Install HXT:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "cabal install hxt",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "strong" [],TagText "Step 2",TagClose "strong",TagText ": Install HandsomeSoup:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "cabal install HandsomeSoup",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "HandsomeSoup contains a powerful ",TagOpen "code" [("class","lang-rb")],TagText "css",TagClose "code",TagText " function that will allow us to access elements using css selectors. We will use this function until we can write a basic version of it ourselves as explained ",TagOpen "a" [("href","#children-and-descendents")],TagText "here",TagClose "a",TagText ". For more info about HandsomeSoup, see ",TagOpen "a" [("href","#introducing-handsomesoup")],TagText "this section",TagClose "a",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "strong" [],TagText "Step 3",TagClose "strong",TagText ": Here\8217s the HTML we\8217ll be working with:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "<html><head><title>The Dormouse's story</title></head>\n  <body>\n<p class='title'><b>The Dormouse's story</b></p>\n\n<p class='story'>Once upon a time there were three little sisters; and their names were\n<a href='http://example.com/elsie' class='sister' id='link1'>Elsie</a>,\n<a href='http://example.com/lacie' class='sister' id='link2'>Lacie</a> and\n<a href='http://example.com/tillie' class='sister' id='link3'>Tillie</a>;\nand they lived at the bottom of a well.</p>\n\n<p class='story'>Some text</p>\n</body>\n</html>",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Save it as ",TagOpen "code" [("class","lang-rb")],TagText "test.html",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "strong" [],TagText "Step 4",TagClose "strong",TagText ": Import HXT, HandsomeSoup, and the html file into ",TagOpen "code" [("class","lang-rb")],TagText "ghci",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "import Text.XML.HXT.Core\nimport Text.HandsomeSoup\nhtml <- readFile \"test.html\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h2" [("id","parse-a-string-as-html")],TagText "Parse a String as HTML",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "readString",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> let doc = readString [withParseHTML yes, withWarnings no] html",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc",TagClose "code",TagText " is now a parsed HTML document, ready to be processed!",TagClose "p",TagText "\n",TagOpen "p" [],TagText "Now we can do things like getting all links in the document:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> doc >>> css \"a\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h2" [("id","arrow-interlude-1-hxt-arrows")],TagText "Arrow Interlude #1: HXT Arrows",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "You just used your first Arrow! ",TagOpen "code" [("class","lang-rb")],TagText "css",TagClose "code",TagText " is an Arrow. Here\8217s its type:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> :t css\ncss :: ArrowXml a => String -> a XmlTree XmlTree",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "So ",TagOpen "code" [("class","lang-rb")],TagText "css",TagClose "code",TagText " takes an ",TagOpen "code" [("class","lang-rb")],TagText "XmlTree",TagClose "code",TagText " and returns another ",TagOpen "code" [("class","lang-rb")],TagText "XmlTree",TagClose "code",TagText ". A lot of Arrows in HXT have this type: they all transform the current tree and return a new tree.",TagClose "p",TagText "\n",TagOpen "h2" [("id","extracting-content")],TagText "Extracting Content",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc",TagClose "code",TagText " is wrapped in an ",TagOpen "code" [("class","lang-rb")],TagText "IOStateArrow",TagClose "code",TagText ". If you try to see the contents of ",TagOpen "code" [("class","lang-rb")],TagText "doc",TagClose "code",TagText ", you\8217ll get an error:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "<interactive>:1:1:\n    No instance for (Show (IOSLA (XIOState s0) a0 XmlTree))\n      arising from a use of `print'\n    Possible fix:\n      add an instance declaration for\n      (Show (IOSLA (XIOState s0) a0 XmlTree))\n    In a stmt of an interactive GHCi command: print it",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "runX",TagClose "code",TagText " to extract the contents.",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "contents <- runX doc\nprint contents",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Prints out:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "[NTree (XTag \"/\" [NTree (XAttr \"transfer-Status\")...]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h2" [("id","pretty-printing")],TagText "Pretty-printing",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "I don\8217t want to see ugly Haskell types. Let\8217s use ",TagOpen "code" [("class","lang-rb")],TagText "xshow",TagClose "code",TagText " to convert our tree to HTML:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "res <- runX . xshow $ doc\nmapM_ putStrLn res",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Prints out:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "</ transfer-Status=\"200\" transfer-Message=\"OK\" transfer-URI=\"string:\" source=\"\"<html><head><title>The Dormouse's story</titl...\"\" transfer-Encoding=\"UNICODE\"><html>\n<head>\n<title>The Dormouse's story</title>\n...",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Much better! Now use ",TagOpen "code" [("class","lang-rb")],TagText "indentDoc",TagClose "code",TagText " to add proper indentation:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "res <- runX . xshow $ doc >>> indentDoc\nmapM_ putStrLn res",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Prints out:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "</ transfer-Status=\"200\" transfer-Message=\"OK\" transfer-URI=\"string:\" source=\"\"<html><head><title>The Dormouse's story</titl...\"\" transfer-Encoding=\"UNICODE\"><html>\n  <head>\n    <title>The Dormouse's story</title>\n...",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Perfect.",TagClose "p",TagText "\n",TagOpen "h2" [("id","selecting-elements")],TagText "Selecting Elements",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "Note: To keep things simple for now, these examples make use of our custom ",TagOpen "code" [("class","lang-rb")],TagText "css",TagClose "code",TagText " Arrow.",TagClose "p",TagText "\n",TagOpen "h3" [("id","get-all-a-tags")],TagText "Get all ",TagOpen "code" [("class","lang-rb")],TagText "a",TagClose "code",TagText " tags",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"a\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","check-if-those-links-have-an-id-attribute")],TagText "Check if those links have an ",TagOpen "code" [("class","lang-rb")],TagText "id",TagClose "code",TagText " attribute",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"a\" >>> hasAttr \"id\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","get-all-values-for-an-attribute")],TagText "Get all values for an attribute",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"a\" >>> getAttrValue \"href\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "See how easy it is to chain transformations together using ",TagOpen "code" [("class","lang-rb")],TagText ">>>",TagClose "code",TagText "? Notice how using ",TagOpen "code" [("class","lang-rb")],TagText "getAttrValue",TagClose "code",TagText " gets us the links for ",TagOpen "em" [],TagText "all",TagClose "em",TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "a",TagClose "code",TagText " tags, instead of just one:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci>runX $ doc >>> css \"a\" >>> getAttrValue \"href\"\n[\"http://example.com/elsie\",\"http://example.com/lacie\",\"http://example.com/tillie\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "This is a core idea behind HXT. In HXT, everything you do is a series of transformations on the whole tree. So you can use ",TagOpen "code" [("class","lang-rb")],TagText "getAttrValue",TagClose "code",TagText " and HXT will automatically apply it to all the elements.",TagClose "p",TagText "\n",TagOpen "h3" [("id","get-all-links-that-have-a-particular-id")],TagText "Get all links that have a particular id",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"a\" >>> hasAttrValue \"id\" (== \"link1\")",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","get-multiple-values-at-once")],TagText "Get multiple values at once",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "<+>",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "-- get all p tags as well as all a tags\ndoc >>> css \"p\" <+> css \"a\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","get-all-element-names")],TagText "Get all element names",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc //> hasAttr \"id\" >>> getElemName",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "We used the special function \8220",TagOpen "code" [("class","lang-rb")],TagText "//>",TagClose "code",TagText "\8221 here! It\8217s covered in ",TagOpen "a" [("href","#children-and-descendents")],TagText "this section",TagClose "a",TagText ".",TagClose "p",TagText "\n",TagOpen "h3" [("id","get-all-elements-where-the-text-contains-mouse")],TagText "Get all elements where the text contains \8220mouse\8221",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "import Data.List\nrunX $ doc //> hasText (isInfixOf \"mouse\")",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","get-the-elements-name-and-the-value-of-id")],TagText "Get the element\8217s name and the value of ",TagOpen "code" [("class","lang-rb")],TagText "id",TagClose "code",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ doc //> hasAttr \"id\" >>> (getElemName &&& getAttrValue \"id\")\n[(\"a\",\"link1\"),(\"a\",\"link2\"),(\"a\",\"link3\")]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Let\8217s talk about the ",TagOpen "code" [("class","lang-rb")],TagText "&&&",TagClose "code",TagText " function.",TagClose "p",TagText "\n",TagOpen "h2" [("id","arrow-interlude-2")],TagText "Arrow Interlude #2",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "&&&",TagClose "code",TagText " is a function for Arrows. The best way to see how it works is by example:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> length >>> (odd &&& (+1)) $ [\"one\", \"two\", \"twee\"]\n(True,4)",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "&&&",TagClose "code",TagText " takes two arrows and creates a new arrow. In the above example, the output of ",TagOpen "code" [("class","lang-rb")],TagText "length",TagClose "code",TagText " is fed into both ",TagOpen "code" [("class","lang-rb")],TagText "odd",TagClose "code",TagText " and ",TagOpen "code" [("class","lang-rb")],TagText "(+1)",TagClose "code",TagText ", and both return values are combined into a tuple ",TagOpen "code" [("class","lang-rb")],TagText "(True, 4)",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "We used ",TagOpen "code" [("class","lang-rb")],TagText "&&&",TagClose "code",TagText " to get an element\8217s name and its id: ",TagOpen "code" [("class","lang-rb")],TagText "(getElemName &&& getAttrValue \"id\")",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "Why is this function useful? Suppose we want to get all attributes on links:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX $ doc >>> css \"a\" >>> getAttrl >>> getAttrName",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Here\8217s where it\8217s nice to have ",TagOpen "code" [("class","lang-rb")],TagText "&&&",TagClose "code",TagText ". The above line gives you something like this:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "[\"href\",\"class\",\"id\",\"href\",\"class\",\"id\",\"href\",\"class\",\"id\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "The only problem: you have no idea what element each attribute belongs to! Use ",TagOpen "code" [("class","lang-rb")],TagText "&&&",TagClose "code",TagText " to get a reference to the element as well:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ doc >>> css \"a\" >>> (this &&& (getAttrl >>> getAttrName))\n[(...some element..., \"href\"), (...another element..., \"class\")..etc..]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "HXT has lots of other arrows for selecting elements. See the ",TagOpen "a" [("href","http://hackage.haskell.org/packages/archive/hxt/9.2.2/doc/html/Text-XML-HXT-Arrow-XmlArrow.html")],TagText "docs",TagClose "a",TagText " for more.",TagClose "p",TagText "\n",TagOpen "h2" [("id","children-and-descendents")],TagText "Children and Descendents",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "HXT has a few different functions for working with children, and it can be tricky to decide which one to use.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "So far we have been using the ",TagOpen "code" [("class","lang-rb")],TagText "css",TagClose "code",TagText " function to get elements. Now let\8217s see how we could implement a basic version of it:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "css tag = multi (hasName tag)",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "css",TagClose "code",TagText " uses ",TagOpen "code" [("class","lang-rb")],TagText "hasName",TagClose "code",TagText " to get elements with a given tag. Why don\8217t we just use ",TagOpen "code" [("class","lang-rb")],TagText "hasName",TagClose "code",TagText " instead of ",TagOpen "code" [("class","lang-rb")],TagText "css",TagClose "code",TagText "?",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ doc >>> hasName \"a\"\n[]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "hasName",TagClose "code",TagText " only works on the current node, and ignores its descendents, whereas ",TagOpen "code" [("class","lang-rb")],TagText "css",TagClose "code",TagText " allows us to look in the entire tree for elements. Here are some arrows for looking in the entire tree:",TagClose "p",TagText "\n",TagOpen "h3" [("id","getchildren-and-multi")],TagText "getChildren and multi",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "We could use ",TagOpen "code" [("class","lang-rb")],TagText "getChildren",TagClose "code",TagText " to get the immediate child nodes:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci>runX $ doc >>> getChildren >>> getName\n[\"html\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "But what if we want the names of all descendents, not just the immediate child node? Use ",TagOpen "code" [("class","lang-rb")],TagText "multi",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ doc >>> multi getName\n[\"/\",\"html\",\"head\",\"title\",\"body\",\"p\",\"b\",\"p\",\"a\",\"a\",\"a\",\"p\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "multi",TagClose "code",TagText " recursively applies an Arrow to an entire subtree. ",TagOpen "code" [("class","lang-rb")],TagText "css",TagClose "code",TagText " uses ",TagOpen "code" [("class","lang-rb")],TagText "multi",TagClose "code",TagText " to search across the entire tree for nodes.",TagClose "p",TagText "\n",TagOpen "h3" [("id","deep-and-deepest")],TagText "deep and deepest",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "These two Arrows are related to ",TagOpen "code" [("class","lang-rb")],TagText "multi",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "deep",TagClose "code",TagText " recursively searches a whole tree for subtrees, for which a predicate holds. The search is performed top down. When a tree is found, this becomes an element of the result list. The tree found is not further examined for any subtress, for which the predicate also could hold:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "-- deep successfully got the name of the root element,\n-- so it didn't go through the child nodes of that element.\nghci> runX $ doc >>> deep getName\n[\"/\"]\n\n-- here, deep will get all p tags but it won't look for\n-- nested p tags (multi *will* look for nested p tags)\nghci>runX $ doc >>> deep (hasName \"p\") >>> getName\n[\"p\",\"p\",\"p\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "deepest",TagClose "code",TagText " is similar to ",TagOpen "code" [("class","lang-rb")],TagText "deep",TagClose "code",TagText " but performs the search from the bottom up:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ doc >>> deepest getName\n[\"title\",\"b\",\"a\",\"a\",\"a\",\"p\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","and")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "/>",TagClose "code",TagText " and ",TagOpen "code" [("class","lang-rb")],TagText "//>",TagClose "code",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "/>",TagClose "code",TagText " looks for a direct child (i.e.\160what ",TagOpen "code" [("class","lang-rb")],TagText "getChildren",TagClose "code",TagText " does).",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "//>",TagClose "code",TagText " looks for a node somewhere under this one (i.e.\160what ",TagOpen "code" [("class","lang-rb")],TagText "deep",TagClose "code",TagText " does).",TagClose "p",TagText "\n",TagOpen "p" [],TagText "So, these two lines are equivalent:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc /> getText\ndoc >>> getChildren >>> getText",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "And these two lines are equivalent:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc //> getText\ndoc >>> getChildren >>> (deep getText)",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "See ",TagOpen "a" [("href","http://hackage.haskell.org/packages/archive/hxt/9.2.2/doc/html/Control-Arrow-ArrowTree.html")],TagText "docs",TagClose "a",TagText " for more.",TagClose "p",TagText "\n",TagOpen "h2" [("id","working-with-text")],TagText "Working With Text",TagClose "h2",TagText "\n",TagOpen "h3" [("id","get-the-text-in-an-element")],TagText "Get the text in an element",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci>runX $ doc >>> css \"title\" /> getText\n[\"The Dormouse's story\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Remember, this is the same as writing:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX $ doc >>> multi (hasName \"title\") >>> getChildren >>> getText",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","get-the-text-in-an-element-all-its-descendents")],TagText "Get the text in an element + all its descendents",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"body\" //> getText",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Try using ",TagOpen "code" [("class","lang-rb")],TagText "/>",TagClose "code",TagText " instead of ",TagOpen "code" [("class","lang-rb")],TagText "//>",TagClose "code",TagText ". What do you get?",TagClose "p",TagText "\n",TagOpen "h3" [("id","get-all-links-their-text")],TagText "Get All Links + Their Text",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "The wrong way:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ doc >>> css \"a\" >>> (getAttrValue \"href\" &&& getText)\n[]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "This returns ",TagOpen "code" [("class","lang-rb")],TagText "[]",TagClose "code",TagText " because ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"a\" >>> getText",TagClose "code",TagText " returns ",TagOpen "code" [("class","lang-rb")],TagText "[]",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "We need to go ",TagOpen "em" [],TagText "deeper",TagClose "em",TagText "! (i.e.\160use ",TagOpen "code" [("class","lang-rb")],TagText "deep",TagClose "code",TagText "):",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ doc >>> css \"a\" >>> (getAttrValue \"href\" &&& (deep getText))\n[(\"http://example.com/elsie\",\"Elsie\"),(\"http://example.com/lacie\",\"Lacie\"),(\"http://example.com/tillie\",\"Tillie\")]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","remove-whitespace")],TagText "Remove Whitespace",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "removeAllWhiteSpace",TagClose "code",TagText ". It removes all nodes containing only whitespace.",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX $ doc >>> css \"body\" >>> removeAllWhiteSpace //> getText",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "If you have used BeautifulSoup, this is kinda like the ",TagOpen "code" [("class","lang-rb")],TagText "stripped_strings",TagClose "code",TagText " method.",TagClose "p",TagText "\n",TagOpen "h2" [("id","modifying-a-node")],TagText "Modifying a Node",TagClose "h2",TagText "\n",TagOpen "h3" [("id","modifying-text")],TagText "Modifying text",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "changeText",TagClose "code",TagText ". Here\8217s how you uppercase all the text in ",TagOpen "code" [("class","lang-rb")],TagText "p",TagClose "code",TagText " tags:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "import Data.Char\nuppercase = map toUpper\nrunX . xshow $ doc >>> css \"p\" /> changeText uppercase",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","add-or-change-an-attribute")],TagText "Add or change an attribute",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "addAttr",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX . xshow $ doc >>> css \"p\" >>> addAttr \"id\" \"my-own-id\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h2" [("id","modifying-children")],TagText "Modifying Children",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "processChildren",TagClose "code",TagText " and ",TagOpen "code" [("class","lang-rb")],TagText "processTopDown",TagClose "code",TagText " allow you to modify the children of an element.",TagClose "p",TagText "\n",TagOpen "h3" [("id","add-an-id-to-the-children-of-the-root-node")],TagText "Add an id to the children of the root node",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "-- adds an id to the <html> tag\nrunX . xshow $ doc >>> processChildren (addAttr \"id\" \"foo\")",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","add-an-id-to-all-descendents-of-the-root-node")],TagText "Add an id to all descendents of the root node",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "-- adds an id to all tags\nrunX . xshow $ doc >>> processTopDown (addAttr \"id\" \"foo\")",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "processChildren",TagClose "code",TagText " is similar to ",TagOpen "code" [("class","lang-rb")],TagText "getChildren",TagClose "code",TagText ", except that instead of returning the children, it modifies them in place and returns the entire tree.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "processTopDown",TagClose "code",TagText " is similar to ",TagOpen "code" [("class","lang-rb")],TagText "multi",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "processTopDownUntil",TagClose "code",TagText " is similar to ",TagOpen "code" [("class","lang-rb")],TagText "deep",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "h2" [("id","conditionals-ifa")],TagText "Conditionals (ifA)",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "HXT has some useful functions that allow us to apply Arrows based on a predicate.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "Using ",TagOpen "code" [("class","lang-rb")],TagText "ifA",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ifA",TagClose "code",TagText " is the if statement for Arrows. It\8217s used as ",TagOpen "code" [("class","lang-rb")],TagText "ifA (predicate Arrow) (do if true) (do if false)",TagClose "code",TagText ".",TagClose "p",TagText "\n",TagOpen "h3" [("id","uppercase-all-the-text-for-p-tags-only")],TagText "Uppercase all the text for ",TagOpen "code" [("class","lang-rb")],TagText "p",TagClose "code",TagText " tags only:",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX . xshow $ doc >>> processTopDown (ifA (hasName \"p\") (getChildren >>> changeText uppercase) (this))",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "We use the identity arrow ",TagOpen "code" [("class","lang-rb")],TagText "this",TagClose "code",TagText " here. You can read this as: if the element is a ",TagOpen "code" [("class","lang-rb")],TagText "p",TagClose "code",TagText " tag, uppercase it, otherwise pass it through unchanged.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "this",TagClose "code",TagText " has a complementary arrow called ",TagOpen "code" [("class","lang-rb")],TagText "none",TagClose "code",TagText ". ",TagOpen "code" [("class","lang-rb")],TagText "none",TagClose "code",TagText " is the zero arrow. Here\8217s how we can use ",TagOpen "code" [("class","lang-rb")],TagText "none",TagClose "code",TagText " to remove all ",TagOpen "code" [("class","lang-rb")],TagText "p",TagClose "code",TagText " tags:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX $ doc >>> processTopDown (ifA (hasName \"p\") (none) (this))",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h2" [("id","more-conditionals-when-guards-and-filtera")],TagText "More Conditionals (when, guards, and filterA)",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "when",TagClose "code",TagText " and ",TagOpen "code" [("class","lang-rb")],TagText "guards",TagClose "code",TagText " can make your ",TagOpen "code" [("class","lang-rb")],TagText "ifA",TagClose "code",TagText " code easier to read.",TagClose "p",TagText "\n",TagOpen "h3" [("id","uppercasing-text-for-p-tags-using-when-instead-of-ifa")],TagText "Uppercasing text for ",TagOpen "code" [("class","lang-rb")],TagText "p",TagClose "code",TagText " tags using ",TagOpen "code" [("class","lang-rb")],TagText "when",TagClose "code",TagText " instead of ",TagOpen "code" [("class","lang-rb")],TagText "ifA",TagClose "code",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX . xshow $ doc >>> processTopDown ((getChildren >>> changeText uppercase) `when` hasName \"p\")\n\nf `when` g -- when the predicate `g` holds, `f` is applied, else the identity filter `this`.",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","deleting-all-p-tags-using-guards")],TagText "Deleting all ",TagOpen "code" [("class","lang-rb")],TagText "p",TagClose "code",TagText " tags using ",TagOpen "code" [("class","lang-rb")],TagText "guards",TagClose "code",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX $ doc >>> processTopDown (neg (hasName \"p\") `guards` this)\n\ng `guards` f -- when the predicate `g` holds, `f` is applied, else `none`.",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","deleting-all-p-tags-using-filtera")],TagText "Deleting all ",TagOpen "code" [("class","lang-rb")],TagText "p",TagClose "code",TagText " tags using ",TagOpen "code" [("class","lang-rb")],TagText "filterA",TagClose "code",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX $ doc >>> processTopDown (filterA $ neg (hasName \"p\"))\n\nfilterA f -- a shortcut for f `guards` this",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h2" [("id","using-functions-as-predicates")],TagText "Using Functions as Predicates",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "How would we get all nodes that have \8220mouse\8221 in the text? Here\8217s one way:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX $ doc //> hasText (isInfixOf \"mouse\")",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "But if the ",TagOpen "code" [("class","lang-rb")],TagText "hasText",TagClose "code",TagText " function didn\8217t exist, we could write it ourselves! Here\8217s how:",TagClose "p",TagText "\n",TagOpen "p" [],TagText "First, import ",TagOpen "code" [("class","lang-rb")],TagText "Text.XML.HXT.DOM.XmlNode",TagClose "code",TagText ". It defines several functions that work on Nodes.",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "import qualified Text.XML.HXT.DOM.XmlNode as XN",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "(Note the qualified import\8230this module has a lot of names that conflict with ",TagOpen "code" [("class","lang-rb")],TagText "HXT.Core",TagClose "code",TagText ").",TagClose "p",TagText "\n",TagOpen "p" [],TagText "Here\8217s a function that returns true if the given node\8217s text contains \8220mouse\8221:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "import Data.Maybe\nimport Data.List\n\nhasMouse n = \"mouse\" `isInfixOf` text \n  where text = fromMaybe \"\" (XN.getText n)",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "isA",TagClose "code",TagText " lifts a predicate function to an HXT Arrow. Combined with ",TagOpen "code" [("class","lang-rb")],TagText "isA",TagClose "code",TagText ", we can use ",TagOpen "code" [("class","lang-rb")],TagText "hasMouse",TagClose "code",TagText " to filter out all nodes that don\8217t have ",TagOpen "code" [("class","lang-rb")],TagText "mouse",TagClose "code",TagText " as part of their text:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "runX $ doc //> isA hasMouse",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "We can use ",TagOpen "code" [("class","lang-rb")],TagText "isA",TagClose "code",TagText " wherever a predicate Arrow is needed: ",TagOpen "code" [("class","lang-rb")],TagText "ifA",TagClose "code",TagText ", ",TagOpen "code" [("class","lang-rb")],TagText "when",TagClose "code",TagText ", ",TagOpen "code" [("class","lang-rb")],TagText "guards",TagClose "code",TagText " etc.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "See the ",TagOpen "a" [("href","http://hackage.haskell.org/packages/archive/hxt/9.2.2/doc/html/Control-Arrow-ArrowIf.html")],TagText "docs",TagClose "a",TagText " for more conditionals for Arrows.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "See these ",TagOpen "a" [("href","http://hackage.haskell.org/packages/archive/hxt/9.2.2/doc/html/Text-XML-HXT-DOM-XmlNode.html")],TagText "docs",TagClose "a",TagText " for more functions you can use to write your own Arrows.",TagClose "p",TagText "\n",TagOpen "h2" [("id","using-haskell-functions")],TagText "Using Haskell Functions",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "Suppose we have an array of link texts:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci>runX $ doc >>> css \"a\" //> getText\n[\"Elsie\",\"Lacie\",\"Tillie\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "And we want to get the length of each bit of text. So we need an arrow version of the ",TagOpen "code" [("class","lang-rb")],TagText "length",TagClose "code",TagText " function.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "We can lift the ",TagOpen "code" [("class","lang-rb")],TagText "length",TagClose "code",TagText " function into an HXT arrow using ",TagOpen "code" [("class","lang-rb")],TagText "arr",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ doc >>> css \"a\" //> getText >>> arr length\n[5,5,6]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "Note how length automatically gets applied to each element without us having to use ",TagOpen "code" [("class","lang-rb")],TagText "map",TagClose "code",TagText ". This is because Arrows in HXT always apply to the entire tree, not just one node. This behaviour is abstracted away so that you can just write a function that works on one node and have it apply to every node in the tree automatically.",TagClose "p",TagText "\n",TagOpen "h2" [("id","working-with-lists")],TagText "Working With Lists",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "This section was written after Ywen asked ",TagOpen "a" [("href","http://www.reddit.com/r/haskell/comments/sbxhb/working_with_html_in_haskell/c4cte0e")],TagText "this question",TagClose "a",TagText " on Reddit. So far, we have applied arrows to one node at a time. In the previous section, we applied ",TagOpen "code" [("class","lang-rb")],TagText "length",TagClose "code",TagText " to every node individually. What if we wanted to work with all the nodes at once, to do a ",TagOpen "code" [("class","lang-rb")],TagText "map",TagClose "code",TagText " or a ",TagOpen "code" [("class","lang-rb")],TagText "foldl",TagClose "code",TagText " over them?",TagClose "p",TagText "\n",TagOpen "p" [],TagText "HXT has some special functions that allow you to work on the entire list of elements, instead of working on just one element.",TagClose "p",TagText "\n",TagOpen "h3" [("id","and-.")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText ">>.",TagClose "code",TagText " and ",TagOpen "code" [("class","lang-rb")],TagText ">.",TagClose "code",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "We already know how to get the text for all links:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ doc >>> css \"a\" //> getText\n[\"Elsie\",\"Lacie\",\"Tillie\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "How do we get the text with the results reversed? Use ",TagOpen "code" [("class","lang-rb")],TagText ">>.",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ (doc >>> css \"a\" //> getText) >>. reverse\n[\"Tillie\",\"Lacie\",\"Elsie\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText ">>.",TagClose "code",TagText " takes a function that takes a list, and returns a ",TagOpen "strong" [],TagText "list",TagClose "strong",TagText ", so it allows us to use all our Haskell list functions.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "We could sort all the letters in the names:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> import Data.List\nghci> runX $ (doc >>> css \"a\" //> getText) >>. (map sort)\n[\"Eeils\",\"Lacei\",\"Teiill\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "How do we count the number of links in the doc? Use ",TagOpen "code" [("class","lang-rb")],TagText ">.",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ (doc >>> css \"a\" //> getText) >. length\n[3]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText ">.",TagClose "code",TagText " takes a function that takes a list and returns a ",TagOpen "strong" [],TagText "single value",TagClose "strong",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "Getting the length of the text of all links combined:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runX $ (doc >>> css \"a\" //> getText >>. concat) >. length\n[16]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "em" [],TagText "The parentheses are important here!",TagClose "em",TagText "\n",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "-- Counts the number of links in the doc\nghci> runX $ (doc >>> css \"a\" //> getText) >. length\n[3]\n\n-- Oops! Runs `>. length` on each link individually\nghci> runX $ doc >>> css \"a\" //> getText >. length\n[1,1,1]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h2" [("id","introducing-handsomesoup")],TagText "Introducing HandsomeSoup",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://egonschiele.github.com/HandsomeSoup/")],TagText "HandsomeSoup",TagClose "a",TagText " is an extension for HXT that provides a complete CSS2 selector implementation, so you can complicated selectors like:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"h1#title\"\ndoc >>> css \"li > a.link:first-child\"\ndoc >>> css \"h2[lang|=en]\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\8230or any other valid CSS2 selector. Here are some other goodies it provides:",TagClose "p",TagText "\n",TagOpen "h3" [("id","getting-attributes-with-handsomesoup")],TagText "Getting Attributes With HandsomeSoup",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "!",TagClose "code",TagText " instead of ",TagOpen "code" [("class","lang-rb")],TagText "getAttrValue",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"a\" ! \"href\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","scraping-online-pages")],TagText "Scraping Online Pages",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "fromUrl",TagClose "code",TagText " to download and parse pages:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc <- fromUrl url\nlinks <- runX $ doc >>> css \"a\" ! \"href\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","downloading-content")],TagText "Downloading Content",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "openUrl",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "content <- runMaybeT $ openUrl url\ncase content of\n    Nothing -> putStrLn $ \"Error: \" ++ url\n    Just content' -> writeFile \"somefile\" content'",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","parse-strings")],TagText "Parse Strings",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "parseHtml",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "contents <- readFile [filename]\ndoc <- parseHtml contents",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h2" [("id","avoiding-io")],TagText "Avoiding IO",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "Look at the type of our html tree:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci>:t doc\ndoc :: IOSArrow XmlTree (NTree XNode)",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "It\8217s in IO! This means that any function that parses the html will have to be IO. What if you want a pure function for parsing the html?",TagClose "p",TagText "\n",TagOpen "p" [],TagText "You can use ",TagOpen "code" [("class","lang-rb")],TagText "hread",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "-- old way:\nghci> let old = runX doc\n\n-- using hread:\nghci> let new = runLA hread contents",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "And here are their types:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> :t old\nold :: IO [XmlTree] -- IO!\n\nghci> :t new\nnew :: [XmlTree] -- no IO!",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "h3" [("id","an-example-getting-all-links")],TagText "An Example: Getting All Links",TagClose "h3",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "ghci> runLA (hread >>> css \"a\" //> getText) contents\n[\"Elsie\",\"Lacie\",\"Tillie\"]",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "So why haven\8217t we been using ",TagOpen "code" [("class","lang-rb")],TagText "hread",TagClose "code",TagText "? Because ",TagOpen "code" [("class","lang-rb")],TagText "IOSArrow",TagClose "code",TagText " is much more powerful; it gives you IO + State. ",TagOpen "code" [("class","lang-rb")],TagText "hread",TagClose "code",TagText " is also much more stripped down. From the docs:",TagClose "p",TagText "\n",TagOpen "blockquote" [],TagText "\n  ",TagOpen "p" [],TagText "parse a string as HTML content, substitute all HTML entity refs and canonicalize tree. (substitute char refs, \8230). Errors are ignored. This is a simpler version of readFromString without any options.",TagClose "p",TagText "\n",TagClose "blockquote",TagText "\n",TagOpen "h2" [("id","debugging")],TagText "Debugging",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "HXT provides arrows to print out the current tree at any time. These arrows are very handy for debugging.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "traceTree",TagClose "code",TagText ":",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"h1\" >>> withTraceLevel 5 traceTree >>> getAttrValue \"id\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "traceTree",TagClose "code",TagText " needs level >= 4.",TagClose "p",TagText "\n",TagOpen "p" [],TagText "Use ",TagOpen "code" [("class","lang-rb")],TagText "traceMsg",TagClose "code",TagText " for sprinkling printf-like statements:",TagClose "p",TagText "\n",TagOpen "pre" [("class","lang-rb")],TagText "\n  ",TagOpen "code" [("class","lang-rb")],TagText "doc >>> css \"h1\" >>> traceMsg 1 \"got h1 elements\" >>> getAttrValue \"id\"",TagClose "code",TagText "\n",TagClose "pre",TagText "\n",TagOpen "p" [],TagText "See the ",TagOpen "a" [("href","http://hackage.haskell.org/packages/archive/hxt/9.2.2/doc/html/Text-XML-HXT-Arrow-XmlState-TraceHandling.html")],TagText "docs",TagClose "a",TagText " for even more trace functions.",TagClose "p",TagText "\n",TagOpen "h2" [("id","epilogue")],TagText "Epilogue",TagClose "h2",TagText "\n",TagOpen "p" [],TagText "I hope you found this guide helpful in your quest to work with HTML using Haskell.",TagClose "p",TagText "\n",TagOpen "div" [("class","figure")],TagText "\n  ",TagOpen "img" [("src","../imgs/happy_einstein.jpg"),("alt","Haskell is awesome! Totes m\8217 goats! - Albert Einstein")],TagClose "img",TagText "\n  ",TagOpen "p" [("class","caption")],TagText "\8220Haskell is awesome! Totes m\8217 goats!\8221 - Albert Einstein",TagClose "p",TagText "\n",TagClose "div",TagText "\n",TagOpen "h3" [("id","key-modules-for-working-with-hxt")],TagText "Key Modules For Working With HXT",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://hackage.haskell.org/packages/archive/hxt/9.2.2/doc/html/Text-XML-HXT-Arrow-XmlArrow.html")],TagText "Arrows for working with nodes",TagClose "a",TagText " (the core stuff).",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://hackage.haskell.org/packages/archive/hxt/9.2.2/doc/html/Control-Arrow-ArrowTree.html")],TagText "Arrows for working with children",TagClose "a",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://hackage.haskell.org/packages/archive/hxt/9.2.2/doc/html/Control-Arrow-ArrowIf.html")],TagText "Conditional Arrows",TagClose "a",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://hackage.haskell.org/packages/archive/hxt/9.2.2/doc/html/Text-XML-HXT-DOM-XmlNode.html")],TagText "Function versions of most Arrows",TagClose "a",TagText " (Useful with ",TagOpen "code" [("class","lang-rb")],TagText "arr",TagClose "code",TagText " or ",TagOpen "code" [("class","lang-rb")],TagText "isA",TagClose "code",TagText ").",TagClose "p",TagText "\n",TagOpen "h3" [("id","more-guides")],TagText "More Guides",TagClose "h3",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://www.haskell.org/haskellwiki/HXT")],TagText "The HXT tutorial on haskell.org",TagClose "a",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://www.haskell.org/haskellwiki/HXT/Practical")],TagText "Practical HXT",TagClose "a",TagText ".",TagClose "p",TagText "\n",TagOpen "p" [],TagText "\n  ",TagOpen "a" [("href","http://en.wikibooks.org/wiki/Haskell/Understanding_arrows")],TagText "Understanding Arrows",TagClose "a",TagText ".",TagClose "p",TagText "\n\n\n\n\n",TagOpen "div" [("id","disqus_thread")],TagClose "div",TagText "\n",TagOpen "script" [("type","text/javascript")],TagText "\n    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */\n    var disqus_shortname = 'aditio'; // required: replace example with your forum shortname\n    // var disqus_developer = 1; // developer mode is on\n\n\n    /* * * DON'T EDIT BELOW THIS LINE * * */\n    (function() {\n        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;\n        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';\n        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);\n    })();\n",TagClose "script",TagText "\n",TagOpen "noscript" [],TagText "Please enable JavaScript to view the ",TagOpen "a" [("href","http://disqus.com/?ref_noscript")],TagText "comments powered by Disqus.",TagClose "a",TagClose "noscript",TagText "\n",TagOpen "a" [("href","http://disqus.com"),("class","dsq-brlink")],TagText "blog comments powered by ",TagOpen "span" [("class","logo-disqus")],TagText "Disqus",TagClose "span",TagClose "a",TagText "\n\n\n        ",TagClose "div",TagText "\n      ",TagClose "div",TagText "\n    ",TagClose "div",TagText "\n    ",TagOpen "script" [("type","text/javascript"),("src","../js/prettify/prettify.js")],TagClose "script",TagText "\n    ",TagOpen "script" [("type","text/javascript"),("src","../js/prettify/lang-hs.js")],TagClose "script",TagText "\n    ",TagOpen "script" [("type","text/javascript"),("src","../js/ga.js")],TagClose "script",TagText "\n\t\t",TagClose "body",TagText "\n\t",TagClose "html",TagText "\n"]
